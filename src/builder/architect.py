from openai import OpenAI
import yaml
import os
client = OpenAI()


def define_project(project_name : str, project_description : str) -> str:

  new_project = f"""
  {project_name}: {project_description}
  """

  response = client.chat.completions.create(
    model="gpt-4-0125-preview",
    messages=[
      {
        "role": "system",
        "content": "You are a helpful, highly skilled and motivated senior developer at a company called Ariad. Your job as as a developer is to create project definitions using our proprietary language for defining project structures. For reference, you have the following documentation:\n\n# Ariad - Declarative Language\n\nAn Ariad project begins with the creation of a YAML document where you declare your project's structure and components. Writing YAML can be intricate, but with ChatGPT, you can easily articulate your project requirements and kickstart the YAML creation process.\n\nStarting an Ariad project involves understanding its various components and how they interact within its unique architecture.\n\n## Architecture\n\nThe architecture of Ariad is designed to be modular and flexible, enabling the independent development and integration of various components. Key concepts include Parts, GLUE, Components, and a Project Manager.\n\n### Parts\n\nEach 'Part' in Ariad represents a self-contained unit with specific inputs and outputs. Parts are designed to be developed independently, allowing for asynchronous and parallel development workflows.\n\n### GLUE\n\n'GLUE' acts as the linker within Ariad, connecting various Parts to form a cohesive Component. It defines how data flows from one Part to another and ensures that all Parts within a Component work in harmony.\n\n### Components\n\nA 'Component' in Ariad is a collection of Parts connected via GLUE. It takes an input, processes it through its constituent Parts, and then outputs the result. Components are the building blocks of an Ariad project, each serving a distinct function within the larger application.\n\n### Project Manager\n\nThe Project Manager in Ariad oversees the overall structure of the program. It defines the necessary Parts, the GLUE that combines these parts, and how they fit into the broader project context.\n\n### Templates\n\nComponents might follow certain templates, like an express backend server, providing a standardized approach to common functionalities within the project.\n\n### Views\n\nAriad offers two primary views - the admin view and the working view. The admin view is for designing Components and the overall project, defining Parts and their interactions. The working view, akin to a leet-code-like interface, allows developers to select or be assigned Parts to code.\n\n## Project Definition in YAML\n\nAriad projects are entirely declared in YAML. This includes defining the project's structure, Components, and their interactions. Here's an example of how a project can be declared:\n\n1. The YAML file starts with the keyword `Project:` followed by the project details.\n2. The project details include:\n   - `Name:`: The name of the project.\n   - `Description:`: A brief description of the project.\n   - A list of components, each starting with a unique identifier like `C_Backend:` or `C_Frontend:`.\n3. Each component has:\n   - `Name:`: The name of the component.\n   - `Description:`: A brief description of the component.\n   - A list of parts, each starting with a unique identifier like `P_AddProduct:` or `P_GetProduct:`.\n4. Each part has:\n   - `Name:`: The name of the part.\n   - `Description:`: A brief description of the part.\n   - `Input:`: The input details, which include:\n     - `Name:`: The name of the input.\n     - `Type:`: The type of the input.\n     - `Description:`: A brief description of the input.\n     - `Properties:`: The properties of the input, each with a `Name:`, `Type:`, and `Description:`.\n     - `Value:`: The value of the input.\n   - `Output:`: The output details, similar to the input details.\n5. Each component also has a `GLUE:` section that describes the flow of data between the parts. It includes:\n   - `Graph:`: The flow of data, represented as `Part1 -> Part2`.\n   - `Description:`: A brief description of the data flow."
      },
      {
        "role": "user",
        "content": "Create a command line app to track TODOs"
      },
      {
        "role": "assistant",
        "content": "```yaml\nProject:\n  Name: Todo App\n  Description: A simple Todo application\n  C_TodoManager:\n    Name: Todo Manager\n    Description: Handles the todo list\n    P_AddTodo:\n      Name: Add Todo\n      Description: Adds a todo to the list\n      Input:\n        Name: todoItem\n        Type: String\n        Description: The todo item to be added\n        Value: \"Buy groceries\"\n      Output:\n        Name: todoList\n        Type: Array\n        Description: The updated todo list\n        Value: [\"Buy groceries\"]\n    P_RemoveTodo:\n      Name: Remove Todo\n      Description: Removes a todo from the list\n      Input:\n        Name: todoItem\n        Type: String\n        Description: The todo item to be removed\n        Value: \"Buy groceries\"\n      Output:\n        Name: todoList\n        Type: Array\n        Description: The updated todo list\n        Value: []\n    GLUE:\n      Graph: P_AddTodo -> P_RemoveTodo\n      Description: Connects the add and remove todo processes\n  C_UserInterface:\n    Name: User Interface\n    Description: Displays the todo list\n    P_DisplayTodos:\n      Name: Display Todos\n      Description: Displays the todo list\n      Input:\n        Name: todoList\n        Type: Array\n        Description: The todo list to be displayed\n        Value: []\n      Output:\n        Name: displayMessage\n        Type: String\n        Description: Message displaying the todo list\n        Value: \"You have no todos left!\"\n    GLUE:\n      Graph: P_DisplayTodos\n      Description: Connects the display todos process\n  C_CLI:\n    Name: Command Line Interface\n    Description: Handles user input and output on the command line\n    P_CLI_Loop:\n      Name: CLI Loop\n      Description: Continuously takes user input and calls the appropriate parts\n      Input:\n        Name: userInput\n        Type: String\n        Description: The user input from the command line\n        Value: \"add Buy groceries\"\n      Output:\n        Name: outputMessage\n        Type: String\n        Description: The output message to be displayed on the command line\n        Value: \"Todo added: Buy groceries\"\n    GLUE:\n      Graph: P_CLI_Loop\n      Description: Connects the CLI loop process\n```"
      },
      {
        "role": "user",
        "content": "Create a program that simulates a pizza shop where we simulate cooking pizzas and eating pizzas."
      },
      {
        "role": "assistant",
        "content": "```yaml\nProject:\n  Name: Pizza Project\n  Description: A simple project with a cook and eater component\n  C_Cook:\n    Name: Pizza Maker\n    Description: Handles the pizza making process\n    P_MakePizza:\n      Name: Make Pizza\n      Description: Makes a pizza from given ingredients\n      Input:\n        Name: ingredients\n        Type: Object\n        Description: Object containing the details of the ingredients\n        Properties:\n          Dough:\n            Type: String\n            Description: Type of dough\n          Sauce:\n            Type: String\n            Description: Type of sauce\n          Toppings:\n            Type: Array\n            Description: Array of toppings\n        Value: '{\"Dough\": \"Thin crust\", \"Sauce\": \"Tomato\", \"Toppings\": [\"Cheese\", \"Pepperoni\"]}'\n      Output:\n        Name: pizza\n        Type: Object\n        Description: Object containing the details of the pizza\n        Properties:\n          Dough:\n            Type: String\n            Description: Type of dough\n          Sauce:\n            Type: String\n            Description: Type of sauce\n          Toppings:\n            Type: Array\n            Description: Array of toppings\n        Value: '{\"Dough\": \"Thin crust\", \"Sauce\": \"Tomato\", \"Toppings\": [\"Cheese\", \"Pepperoni\"]}'\n    GLUE:\n      Graph: P_MakePizza\n      Description: Connects the pizza making process\n  C_Eater:\n    Name: Pizza Eater\n    Description: Eats the pizza and gives feedback\n    P_EatPizza:\n      Name: Eat Pizza\n      Description: Eats the pizza and gives an appreciation message\n      Input:\n        Name: pizza\n        Type: Object\n        Description: Object containing the details of the pizza\n        Properties:\n          Dough:\n            Type: String\n            Description: Type of dough\n          Sauce:\n            Type: String\n            Description: Type of sauce\n          Toppings:\n            Type: Array\n            Description: Array of toppings\n        Value: '{\"Dough\": \"Thin crust\", \"Sauce\": \"Tomato\", \"Toppings\": [\"Cheese\", \"Pepperoni\"]}'\n      Output:\n        Name: appreciationMessage\n        Type: String\n        Description: Appreciation message after eating the pizza\n        Value: \"The pizza was delicious!\"\n    GLUE:\n      Graph: P_EatPizza\n      Description: Connects the pizza eating process\n```"
      },
      {
        "role": "user",
        "content": "Create an MUN assistant: An easy way to keep track of people’s speeches, recognition by the chairs, motions proposed, and more. A tool to make moderating easier and allow them to make the most out of their and delegates' times."
      },
      {
        "role": "assistant",
        "content": "```yaml\nProject:\n  Name: \"MUN Conference Whisper Command Recognition\"\n  Description: >\n    An easy way to keep track of people’s speeches, recognition by the chairs, motions proposed, and more. \n    A tool to make moderating easier and allow them to make the most out of their and delegates' times.\n\n  C_AudioProcessing:\n    Name: Audio Processing\n    Description: >\n      Handles the processing of audio input, including speech recognition and command classification.\n    P_RecordSnippet:\n      Name: Record Snippet\n      Description: Records a snippet of audio\n      Input:\n        Name: duration\n        Type: Number\n        Description: The duration of the audio snippet\n        Value: 5\n      Output:\n        Name: audio\n        Type: String\n        Description: The audio file\n        Value: \"audio.wav\"\n    P_Recognize:\n      Name: Recognize\n      Description: Recognizes the speech and returns the recognized text\n      Input:\n        Name: audio\n        Type: String\n        Description: The audio file to be recognized\n        Value: \"audio.wav\"\n      Output:\n        Name: recognizedText\n        Type: String\n        Description: The recognized text\n        Value: \"Hello, my name is John Doe\"\n    P_Classify:\n      Name: Classify\n      Description: Classifies the recognized text into a command\n      Input:\n        Name: recognizedText\n        Type: String\n        Description: The recognized text\n        Value: \"... is the reason why. The delegate of the United States has the floor.\"\n      Output:\n        Name: command\n        Type: String\n        Description: The classified command\n        Value: \"FLOOR.USA\"\n\n    GLUE:\n      Graph: P_RecordSnippet -> P_Recognize -> P_Classify\n      Description: Connects the recognition process to the command classification\n\n  C_ConferenceManagement:\n    Name: Conference Management\n    Description: >\n      Manages various aspects of the conference, including handling commands, managing the speaker list, and processing motions.\n    P_HandleCommand:\n      Name: Handle Command\n      Description: Handles the classified command and determines the appropriate action\n      Input:\n        Name: command\n        Type: String\n        Description: The classified command\n        Value: \"FLOOR.USA\"\n      Output:\n        Name: action\n        Type: String\n        Description: The action to be performed\n        Value: \"Delegate of the United States has the floor.\"\n    P_UpdateSpeakersList:\n      Name: Update Speakers List\n      Description: Updates the speakers list based on classified commands\n      Input:\n        Name: command\n        Type: String\n        Description: Command indicating a speaker addition or removal\n        Value: \"ADD_SPEAKER.USA\"\n      Output:\n        Name: speakerListUpdate\n        Type: String\n        Description: Update action for the speakers list\n        Value: \"Added USA to speakers list.\"\n    P_HandleMotion:\n      Name: Handle Motion\n      Description: Processes and logs motions proposed by delegates\n      Input:\n        Name: command\n        Type: String\n        Description: Command indicating a motion\n        Value: \"MOTION.USA.2MIN\"\n      Output:\n        Name: motionProcessed\n        Type: String\n        Description: The processed motion\n        Value: \"Processed 2-minute motion from USA.\"\n    GLUE:\n      Graph: P_HandleCommand -> P_UpdateSpeakersList -> P_HandleMotion\n      Description: Connects command handling, speaker list updating, and motion processing\n\n  C_TimeManagement:\n    Name: Time Management\n    Description: >\n      Manages the time for each speech and session in the conference.\n    P_ManageTime:\n      Name: Time Management\n      Description: Manages and logs time for speeches and sessions\n      Input:\n        Name: command\n        Type: String\n        Description: Command to start, stop, or update time\n        Value: \"TIME_START.USA\"\n      Output:\n        Name: timeStatus\n        Type: String\n        Description: The status of the time management\n        Value: \"Time started for USA's speech.\"\n    GLUE:\n      Graph: P_ManageTime\n      Description: Connects time management to the overall system\n```"
      },
      {
        "role": "user",
        "content": new_project
      }
    ],
    temperature=0.7,
    max_tokens=2000,
    top_p=1,
    frequency_penalty=0,
    presence_penalty=0
  )

  txt = response.choices[0].message.content
  txt = txt.replace("```yaml", "").replace("```", "")
  project = yaml.safe_load(txt)
  project_name = project_name.replace(" ", "_")
  file_name = f"{project_name}.ariad.yaml"
  with open(file_name, 'w') as f:
    yaml.dump(project, f, default_flow_style=False, sort_keys=False)
  abs_path = os.path.abspath(file_name)
  return abs_path

